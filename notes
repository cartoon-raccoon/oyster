Oyster - A shell written in Rust

Mostly POSIX-compliant; is essentially a re-implementation of Zsh/Bash in Rust

Plans might include to implement a custom scripting language

Other names:
Oyshter? (Ew)

Built-in commands:
cd *
which *
eval
source
export *
echo
read
kill
alias *
let *
exit *

Features:
Autocompletion
job control (done)
Basic scripting
shell expansions
    -> $(command) || `command` (done)
    -> $variable (done)
    -> ~ to home dir (done)
    -> - (when used with cd) to previous dir
    -> !! to last command (in editor)
    -> button.{js, css} to button.js, button.css (done)

Todo:
Finish implementing scripting
Implement history and completion
Implement process substitution
Implement stdin redirection
Implement globbing
Implement variable types using enums
  - Ints
  - Strings
  - Arrays (add parenthesis detection to the parser)
Add square bracket and parenthesis detection to parser
For scripting:
    Implement square bracket expansion (range) e.g. for i in [1..5]
    Implement if (and comparison operators)
    Implement case statement
    Implement logical operators (OR, AND)
Break up the token parser function into smaller functions
    for the shell expansion to use part of the functionality
instead of passing execute() a set of params, pass it a Context
allowing execute() to run for different purposes, i.e. command substitution

Bugs:
Fix escaping for $
Fix newlines in command substitution
Fix redirection order

My preferred prompt:
export OYSTER_PROMPT="{YELLOW_B}{USER}{RESET}: {BLUE}{CWD_FULL}{RESET}{NEWLINE}{COLOR_ST}â¯{RESET} "

Scripting constructs:
Add a shell state - in loop (while waiting for new input)
for and while trigger this state, exited with 'done'
if and switch triggers if-state which lasts until done
implement functions

commands that trigger waiting -> ending word:
function -> end
if -> end
else -> end
elif -> end
while -> done
for -> done


during startup, the shell needs to determine whether it is is interactive mode
(implement this by looking at arguments)

if not in interactive mode, must be in script execution mode
script execution mode enforces the use of certain commands to indicate start and end of loops

shell syntax
